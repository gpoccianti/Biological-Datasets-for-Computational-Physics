# -*- coding: utf-8 -*-
"""ARC_TAU_new.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jrCCEeak5QjSKiatWG8MfvZ4-N3gJrME

# Colab-specific instructions start here
"""

# Here we use a Conda environment inside Google Colab. Blocks specific for Colab
# (like this one) mention "condacolab". On "normal" platforms the procedure
# for installation may be different - you need to check the system's documentation.

# Colab notebooks are "brittle": in the course of time Colab is updated
# and dependencies no longer work properly. Proper HPC platforms are more
# stable (and supported)

# After executing this cell, Colab restarts.

#!pip install -q condacolab
#import condacolab
#condacolab.install_miniforge()

print("\n")
#Install mdtraj
#!pip install mdtraj
#!pip install Bio
#!pip install MDAnalysis

# Verify Python version
import sys
sys.version

#import condacolab
#condacolab.check()

# Colab-specific workaround for a weird error upon shell escape:
#   NotImplementedError: A UTF-8 locale is required. Got ANSI_X3.4-1968
#import locale
#def getpreferredencoding(do_setlocale = True):
#    return "UTF-8"
#locale.getpreferredencoding = getpreferredencoding

"""# Generic installation instructions"""

# Verify GPU availability and type. If you get an error, check that
# "Runtime / Runtime type / GPU" is selected.
#!nvidia-smi


"""# Here begins the simulations proper"""

from openmm.app import *
from openmm import *
from openmm.unit import *
from pdbfixer import *
from sys import stdout

import numpy as np
import mdtraj as mdt

import random

# Set random seed for reproducibility
random.seed(42)

"""## Create integration-related objects"""

filename="complex"

# The FF object holds the parameters
forcefield = ForceField("amber14-all.xml", "amber14/tip3p.xml")

# Set up the system with the force field and periodic boundary conditions

# Load the solvated PDB file
pdb = PDBFile("sol_" + filename + ".pdb")
modeller = Modeller(pdb.topology, pdb.positions)

# Define forcefield
forcefield = ForceField("amber14-all.xml", "amber14/tip3p.xml")

# Specify the system to be simulated
system = forcefield.createSystem(
    modeller.topology,
    nonbondedMethod=PME,           # Particle Mesh Ewald (PME) for long-range electrostatics with PBC
    nonbondedCutoff=1 * nanometer, # Nonbonded cutoff distance
    constraints=HBonds             # Constrain hydrogen bonds to increase timestep stability
)

"""## Rigid bodies
Make the Viral domain and C terminal of ARC rigid bodies (this will be crucial for our simulations)
"""

from rigid import createRigidBodies

# Identify atom indices for rigid bodies
n_terminal_indices = [
    atom.index for atom in pdb.topology.atoms()
    if atom.residue.chain.id == 'A' and 17 <= int(atom.residue.id) <= 155
]
capsid_indices = [
    atom.index for atom in pdb.topology.atoms()
    if atom.residue.chain.id == 'A' and 205 <= int(atom.residue.id) <= 365
]

# Combine the rigid bodies into a list
rigid_bodies = [n_terminal_indices, capsid_indices]

#Check this
positions = pdb.positions

# Apply rigid body constraints
createRigidBodies(system, positions, rigid_bodies)

#Simulation temperature
T=300*kelvin
# Specify the integrator: temperature, relaxation time, timestep (important)
integrator = LangevinMiddleIntegrator(T, 1 / (picosecond), 2 * femtoseconds) #timestep=0.002 * picoseconds

# The barostat is added to the system so that density is controlled
# in addition to temperature.

# Pressure, Temperature (only used for calculation),
# Frequency (how frequently the system should update the box size)
barostat = MonteCarloBarostat(1.0 * atmosphere,T, 25)

system.addForce(barostat)

# Combines the molecular topology, system, and integrator
# to begin a new simulation.
simulation = Simulation(modeller.topology, system, integrator)
simulation.context.setPositions(modeller.positions)

"""## Minimize energy"""

#np.random.seed(123456)
# Perform local energy minimization
print("Minimizing energy...")
simulation.minimizeEnergy(maxIterations=500)


# Write the minimized coordinates (for checking)
PDBFile.writeFile(
    simulation.topology,
    simulation.context.getState(getPositions=True).getPositions(),
    open(filename+"-minimized.pdb", "w"),
    keepIds=True,
)

# Get the final energy of the system
state = simulation.context.getState(getEnergy=True)
final_energy = state.getPotentialEnergy()

# Print the final energy
print(f"Final energy: {final_energy} kJ/mol")

"""## Integrate"""

Nsteps = int(1e7)
from simtk import openmm, unit
from simtk.openmm import app
from simtk.openmm.app import DCDReporter, PDBReporter, XTCReporter

report_Interval=int(1e5)

# When the simulation runs, it will write the trajectory to a file called "output.pdb"
dcd_reporter = DCDReporter("output.dcd", reportInterval=report_Interval, enforcePeriodicBox=True)
simulation.reporters.append(dcd_reporter)


# Append the XTCReporter to save trajectory every 1000 steps
#simulation.reporters.append(
#    XTCReporter("output.xtc", reportInterval=Nsteps, enforcePeriodicBox=True)
#)

# Append the PDBReporter to save trajectory every 1000 steps
simulation.reporters.append(
    PDBReporter("output.pdb", reportInterval=report_Interval, enforcePeriodicBox=True)
)

# Also report infomation to the screen as the simulation runs
simulation.reporters.append(
    StateDataReporter(
        stdout,
        100,
        step=True,
        time=True,
        potentialEnergy=True,
        kineticEnergy=True,
        totalEnergy=True,
        temperature=True,
        volume=True,
        density=True,
        progress=True,
        remainingTime=True,
        speed=True,
        elapsedTime=True,
        separator=" ",
        totalSteps=Nsteps,
    )
)

# Finally run the simulation for the given timesteps
print("Running simulation...")
simulation.step(Nsteps)

with open(filename + "-final.pdb", "w") as final_pdb:
    PDBFile.writeFile(
        simulation.topology,
        simulation.context.getState(getPositions=True).getPositions(),
        final_pdb,
        keepIds=True
    )

